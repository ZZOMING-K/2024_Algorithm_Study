문제 링크 : boj.kr/1260

문제 요약 : 정점들과 간선들을 입력받고, 시작정점으로부터 DFS, BFS 탐색을 했을 때 방문할 수 있는 정점을 순서대로 출력한다

접근 방법 : 
우선 입력받은 간선들을 2차원 배열형태로 표현하였다. (예를 들어 1, 2 정점에 간선이 있는 경우 L[1][2]와 L[2][1]을 True로 하는 방식으로 2차원 배열을 만들었다.)
이 2차원 배열을 L이라고 하겠다.

DFS를 구현하기 위해 스택 자료구조를 사용하였다. (FILO)
시작 정점에서 출발하여 각 정점에 연결된 정점을 찾기 위해 L[현재 탐색하고자하는 정점]을 순차탐색하며, 연결되어있는 정점을 발견하면 스택에 추가하고, 현재 정점을 발견한 정점으로 하여 DFS를 수행한다.
visitOrder배열로 이미 방문한 정점인지 확인하여 같은 정점은 두 번 이상 방문하지 않게 하였다.
즉 스택에는 시작 정점부터 발견하는 정점 순서대로 정점의 번호가 들어간다.
만약 L배열을 끝까지 탐색하였으나 연결된 정점을 발견하지 못 한 경우, 해당 정점에는 더 이상 탐색할 정점이 없다는 의미이다. 이전 정점으로 돌아가서 다시 DFS를 수행해야 하므로 stack에서 하나를 pop하여 현재정점으로 하고, 다시 DFS 한다.
스택의 처음에 위치하는 시작 정점에서 조차 더 이상 연결된 정점이 없는 경우, DFS를 완료한 것이므로 종료한다.

BFS를 구현하기 위해 큐 자료구조를 사용하였다. (FIFO)
시작 정점을 현재 정점으로 하여 연결된 모든 정점을 큐에 삽입하고, 큐에서 하나씩 pop한 값을 현재 정점으로 하여 큐가 빌 때까지 반복한다.