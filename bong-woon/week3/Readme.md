
## < 3주차 회고 (이진 탐색 / 스택 & 큐) >
---
### [3주차] 해결한 과제
##### 문제 1920 : 수 찾기
- https://www.acmicpc.net/problem/1920

**<접근 방법>**  
  
- 이진 탐색을 활용해서 보다 빠르게 검색을 할 수 있게 코드를 작성했습니다. 이진 탐색을 위해서 검색 대상이 되는 N개의 정수는 리스트로 입력을 받은 후, 오름차순으로 정렬을 했습니다. 그리고 "bin_search" 함수를 정의해서 검색하지 못한 경우(= start > end) 검색하려는 값을 찾은 경우를 제외하고는 재귀적으로 bin_search 호출합니다. 이 때, 호출된 bin_search의 파라미터인 start와 end는 상황에 따라서 새롭게 갱신된 start와 end를 넣어줍니다.

- 초기 start = 0, end = (검색 대상의 길이 - 1)로 한 뒤, 두번째 리스트에 입력 받은 원소들을 하나씩 이진 검색을 하면서 결과에 따라 1, 0을 출력하도록 작성했습니다.

---

##### 문제 2805 : 나무 자르기
- https://www.acmicpc.net/problem/2805

**<접근 방법>**  

- 이진 탐색을 하면서 계산되는 중앙값을, 이진 탐색을 계속 반복하면서 업데이트를 해가면서 정답을 출력하게 했습니다.
- 가운데 값(mid)을 자르는 높이라고 생각하고, 그 높이로 잘랐을 때 자르고 남은 나무 길이를 모두 더했습니다. 상근이가 가져가려고 하는 나무 길이보다 많으면 자르는 높이를 조금 더 높게 설정하고, 모자르다면 조금 더 낮게 설정해서 최적의 높이를 찾게끔 코드를 작성했습니다.

---

##### 문제 24511 : queuestack
- https://www.acmicpc.net/problem/24511

**<접근 방법>**  

- 두 번 정도 아이디어를 수정해가면서 풀었습니다. 
    - 처음에는 문제의 조건대로 0일 때는 큐, 1일 때는 스택을 만들어서 모든 원소가 순서대로 스택과 큐를 통과하게 한 뒤 결과를 출력했습니다. 하지만 백준에서는 시간 초과 문제가 발생했습니다.
    - 두번째는 스택을 들어갔다 나올 때는 결국에 들어간 원소가 다시 나오는 것이기 때문에 스택은 굳이 필요가 없겠다는 생각을 했고, 0인 경우에만 큐를 만들어서 순서대로 큐를 통과하게 만들었지만 또 시간 초과 문제가 발생했습니다.
        - 리스트만 존재하는 경우에는 결국 새롭게 추가하려는 숫자를 그대로 출력해주면 되기 때문에 첫번째 리스트(an)에 0이 하나도 없는 경우(= 스택만 있는 경우)에는 나중에 입력받는 값(push_ele)을 순서대로 출력해줬습니다.
    - 마지막으로는 여러 개의 큐를 만들 필요없이 큐마다 담긴 원소를 큐 하나에 담아도 문제가 없겠다는 생각을 했습니다. 그래서 `q.popleft()`를 통해 큐에 가장 먼저 들어온 원소들을 순서대로 출력했습니다.

---

##### 문제 1874 : 스택 수열
- https://www.acmicpc.net/problem/1874

**<접근 방법>**  
  
- 만드려고 하는 수열을 sequence라는 리스트에 순서대로 저장하고, 빈 리스트 stack에 오름차순 순서대로 1부터 N까지 push와 pop을 반복합니다. i는 sequence의 인덱스로서 초기값은 0으로 설정해주고, num은 stack에 순차적으로 push와 pop을 반복하는 원소로서 초기값은 1입니다. 이 때 반복하는 조건은 다음과 같습니다.
    - sequence의 인덱스 i가 n보다 작을동안 계속 반복
        - sequence\[i\]가 num보다 큰 경우에는
            - stack에 append를 해주고
            - outputs에 '+'를 append 한 뒤
            - num을 1 증가 시켜줍니다
        - sequence\[i\]가 num과 같은 경우에는
            - stack에 append를 해주고
            - outputs에 '+'를 append 한 뒤
            - stack에서 다시 pop을 합니다.
            - outputs에는 '-'를 append 하고
            - i와 num을 모두 +1을 해줍니다.
        - sequence\[i\]가 num보다 작은 경우에는
            - sequence\[i\]가 stack의 마지막 원소라면
                - stack에서 pop을 하고
                - outputs에 '-'를 append 한 뒤
                - i를 1 증가 시켜줍니다.
            - sequence\[i\]가 stack의 마지막 원소가 아니라면
                - outputs에 'NO'를 append하고
                - break로 while문을 중단합니다.
- outputs는 '+', '-' 혹은 'NO'의 결과를 담는 리스트입니다. 처음에는 `print()`를 통해 바로 '+', '-'를 출력했지만 수열을 만드는게 불가능한 경우에는 'NO'만 출력해야 하는데 처음부터 모든 과정이 출력되는 문제가 있었습니다.
    - 그래서 바로 출력하지 않고 outputs에 '+', '-'를 작업 순서대로 모두 담고, for문을 통해 outputs에 원소들을 하나씩 출력했습니다.
    - 'NO'가 outputs에 있는 경우에는 for문 없이 바로 'NO'를 출력하게 했습니다.

##### 문제 1966 : 프린터 큐
- https://www.acmicpc.net/problem/1966

**<접근 방법>**  

- 문서가 출력되는 경우는 `popleft()`로 처리하고, 출력되지 않고 다시 제일 뒤로 이동하는 경우는 `popleft()`한 결과를 다시 `append` 해주었습니다. 이 때, `popleft()`와 `append`를 반복하면서 인덱스가 바뀌게 되는데 찾고자 하는 문서의 처음 인덱스를 저장하기 위해 인덱스도 0부터 n-1까지 큐에 저장했습니다. 그래서 문서가 출력되는 경우에는 인덱스도 같이 pop이 되고, 제일 뒤로 이동하는 경우에도 같이 pop이 된 뒤 push를 해주었습니다. 그리고 원래 인덱스가 m이었던 문서가 출력될 때, 그 때의 순서(order)를 출력하게 작성했습니다.

---
---
### [3주차] 해결하지 못한 과제

##### 문제 2110 : 공유기 설치
- https://www.acmicpc.net/problem/2110

**<접근 방법>**  
  
- 나무 자르기 문제와 비슷하다고 생각하고 접근했습니다. 하지만 나무 자르기 문제의 경우는 이진 검색을 통해 자르고, 최댓값을 구하는 로직을 비교적 쉽게 생각해 낼 수 있었는데, 이 문제는 공유기 간의 거리를 어떻게 최적화 하는지에 대한 로직이 쉽게 떠오르지 않았습니다. 그래서 검색을 통해 이진 검색을 통한 매개 변수 최적화에 대해서 조금 더 찾아보고, 다른 사람의 풀이를 보면서 로직을 이해하는데 초점을 맞췄습니다.

- start=1 : 공유기 간의 거리 중 최솟값. 한 집에 공유기를 여러 개 설치할 수 없고 집의 위치는 겹치지 않기 때문에 최소 거리는 1이 됩니다.
- end : 공유기 간의 거리 중 최댓값. 집 위치에 대한 정보를 오름차순 정렬했을 때, 첫번째 집과 마지막 집까지의 거리가 최댓값이 됩니다.
- distance : 공유기 간의 거리. start와 end의 평균값(소수점은 버림)으로 설정해서 이 값이 최댓값이 되게 계속 업데이트를 해줍니다.
    - 로직:
    - 첫번째 집에 공유기를 설치하고(count += 1) 현재 집(방금 공유기를 설치한 집)과 나머지 집 사이들의 거리를 비교합니다.
        - 이 때, 현재 집과 나머지 집들과의 거리를 계산했을 때 distance보다 크거나 같으면
            - 그 위치에 공유기를 설치하고(count += 1), 갱신된 set_home(=home_location[i])에서부터 그 다음 집까지의 거리를 계속 distance와 비교하면서 공유기를 설치합니다.
        
        - 이렇게 for문을 다 돌고 설치한 공유기 개수(count)가 설정한 공유기 개수(c)보다 많으면 distance가 너무 작아서 마지막 집까지 설치하는데 공유기가 많이 필요했다는 의미입니다.
            - 그래서 공유기 간의 최소 거리(start)를 distance + 1로 업데이트 해줍니다.
        - 반대로 설치한 공유기 개수가 설정한 공유기 개수 보다 적으면 간격이 너무 넓어서 설정한 개수만큼 설치하지 못한 것입니다.
            - 그러므로 공유기 간의 최대 거리(end)를 distance - 1로 업데이트 해줍니다.
---
---
### [3주차] 처음 써본 함수 및 라이브러리



