문제 링크 : boj.kr/1202

문제 요약 : 가방에는 수용가능한 무게가 있고, 보석에는 무게와 가치가 있다. 가방의 가치를 가장 높일 수 있는 보석들을 훔친다.

제한 사항 :
보석 개수와 가방 개수의 상한은 300,000이다.
O(N)으로 구현한다면 최대 600,000번 정도의 연산이,
O(NlogN)으로 구현한다면 최대 10,800,000번 정도의 연산이,
O(N^2)으로 구현한다면 최대 360,000,000,000 정도의 연산이 필요할 것이다.
파이썬은 1초에 20,000,000번 정도 연산이 가능하다고 하고, 이 문제의 제한 시간도 1초이므로
O(N^2) 이상의 시간 복잡도로 구현하면 안 된다.

내가 생각해본 접근 방법 :
관건은 '어떤 기준으로 각 가방에 최적의 보석을 선택하는가' 이다.
제한 사항이 엄격한 가방(수용가능 무게가 가장 작은 가방)부터 보석을 넣어가면 최선의 선택을 할 수 있다.
작은가방에는 들어가고 큰 가방에는 들어가지 않는 보석은 없기 때문이다.

이를 구현하기 위해 우선순위 큐 자료구조를 사용하였다.
우선순위 큐의 장점 : 최대값(최소값)을 찾기 매우 빠르다. 값을 넣을 때 최대(최소)값인 경우 자동으로 큐의 맨 앞으로 이동하여 최대(최소)값이 필요한 경우 따로 정렬할 필요가 없다.
우선순위 큐의 삽입 시간은 O(logN)이고, 최대(최소)값을 꺼내는 시간은 O(1)이다.
import heapq로 모듈을 가져와서 heapq.heappush(삽입하고싶은 배열, 삽입할 값) 로 값을 삽입하고, heapq.heappop(pop하고싶은 배열) 로 최대(최소)값을 꺼낸다.


사용한 우선순위 큐 : backpack(입력 받은 가방들이 저장될 우선순위 큐), jewel(입력 받은 보석들이 저장될 우선순위 큐), leftJewel(현재의 가방에 들어갈 수 있는 보석들이 저장될 우선순위 큐)
jewel 배열 중 backpack의 크기로 수용할 수 있는 보석들은 leftJewel 배열로 이동한다.
만약 가방이 수용할 수 없는 보석이 pop된 경우, 해당 보석을 다시 jewel배열에 넣고, 정답에 leftJewel배열의 최대값을 더한다.
모든 보석을 전부 수용할 수 있는 경우 (jewel배열이 빈 경우) 남은 가방의 개수만큼 leftJewel의 최대값을 꺼내 더한다.