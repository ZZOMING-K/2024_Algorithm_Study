# ✍️ 1주차 회고
</br>

## GREEDY(그리디,탐욕법)

- **현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미합니다.**
- 즉. 현재 상황에서 보는 선택 지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘입니다.
- 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구합니다.
- 그리디 해법은 그 **정당성 분석**이 중요합니다.
    - **단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토합니다.**

</br>

## 새로 알게 된 점 

### Append 와 Extend의 차이점

- append : 매개변수 그 자체를 원소로 넣음
- extend : 가장 바깥쪽 iterable을 넣음

append는 매개변수로 받는 원소 그대로의 값을 리스트 안으로 집어넣고, extend는 가장 바깥쪽 iterable의 모든 항목을넣습니다. 

```python
x = [1,2,3]
y = [4,5]
x.append(y) 
print('append : ' , x) 

x= [1,2,3]
y = [4,5] 
x.extend(y)
print('extend : ' , x) 

append :  [1, 2, 3, [4, 5]]
extend :  [1, 2, 3, 4, 5]
```

### 리스트를 문자열로 변환

리스트를 문자열로 변환 → “”.join(리스트) 

```python
fruit = ['a','p','p','l','e'] 
result = ''.join(fruit) 
print(result) 

#output 
'apple' 
```

### Sorted와 Sort의 차이점

   

- sort함수는 list 클래스의 메서드로 **list 객체에만 사용가능하다.**
- sorted 함수는 **객체(list , string, tuple , dict ...) 을 파라미터로 받을 수 있는 메서드**이다.

sort는 기존의 list의 정렬 정보가 필요없고 **그 객체 자체를 정렬하고 싶을 때 사용하는 것이 효율적**이다. sorted는 기존의 list의 정렬 정보가 유의미하고 **다른 객체를 생성해 저장하고 싶을 때 사용한다.** 

즉, **sorted는 기존의 list를 copy 한 후 새롭게 생성된 list에 sort를 적용한 것과 같은 역할**을 하는 것이다.

### 배수판별법

- 3의 배수 : **각 자리 숫자의 합이 3의 배수인 수**
- 4의 배수 : 끝의 두 자리수가 00 또는 4의 배수인 수
- 5의 배수 : 일의 자리 숫자가 0 또는 5인 수
- 6의 배수 : 3의 배수이면서 짝수인 수
- 9의 배수 : 각 자리 숫자의 합이 9의 배수인 수

</br>

## 느낀점  🤔

### **규칙발견의 중요성 ?** 

문제를 풀이하는 데 있어 규칙을 발견하게 된다면 쉽고 간결하게 코드 구현이 가능해진다고 생각됩니다.  규칙을 발견하는 과정이 어렵지만, 일단은 직접 써보고 생각해보는 것이 우선인 것을 알게되었다.

### **스터디의 중요성** 

역시나 스터디를 진행한 결과, 첫 주차 부터 스터디의 장점이 확 와닿았다. 스터디원들의 다양한 아이디어와 코드를 보면서 내 코드와 비교할 수 있고, 또 더 좋은 방법을 알 수 있어서 좋았다.

코드의 효율적인 방면이나 새로운 문법 등에 대해 배워가는 것이 많다고 느껴진다.    

또한, 알고리즘 공부의 경우에는 꾸준함이 중요하다고 생각되는데 스터디로 인해 강제성이 어느정도 부여되는 점 또한, 좋게 생각한다. 

</br>

## 문제풀이 

1. 30018 - 타슈

영우는 자전거를 최소 몇번을 옮겨야하는지 구하는 문제였습니다. 단순하게 a_i 자전거 수가 b_i 자전거 수보다 클 경우 i 대여소에 a_i - b_i 만큼의 자전거 수가 필요한 것 입니다. 총 자전거 수는 동일하므로 각 대여소에 부족한 자전거 수를 구해주면 됩니다.

2. 16435 - 스네이크버드

과일들을 먹어 늘릴 수 있는 최대길이를 구하기 위해서는 과일을 많이 먹어야 합니다.

과일을 먹으면 길이가 늘어나므로 간단하게 과일 높이가 작은 길이 부터 정렬하여 풀이했습니다.

3. 11399 - ATM

각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하기 위해서는 단순히 오름차순으로 돈을 인출하는데 필요한 시간을 정렬하여 합을 구하면 되는 문제였습니다.

4. 1439 - 뒤집기

우선은 연속된 숫자를 그룹으로 생각했습니다.

1111001111 의 경우에는 1 0 1 -> 1그룹 2번, 0그룹 1번이고 그렇다면 0의 그룹을 한번만 뒤집으면 모든 숫자가 1이 되므로 1번만 뒤집으면 된다.

최소로 뒤집는 횟수를 구하기 위해서는 그룹 수가 적은 횟수만큼 뒤집으면 됩니다.

따라서 1 그룹을 count 할 때 '10' 을 count 하고, 0 그룹을 count 할 때 '01'을 count 해주었습니다. 또한 마지막 그룹을 알기 위해서 마지막 숫자 그룹에 +1을 처리를 진행해주었습니다.

5. 10610 - 30
    1. 30의 배수가 되기 위해서는 10의 배수이면서 3의 배수여야 합니다.
    2. 10의 배수가 되기 위해서는 0으로 숫자가 끝나야 합니다.
    3. 3의 배수가 되기 위해서는 각 자리 수의 합이 3의 배수여야 합니다.

숫자를 내림차순으로 정렬 후 위 조건에 해당하지 않는 경우는 -1리턴

해당하는 경우에는 join으로 문자열을 합쳐서 return 해주었습니다.

6. 18008 - Remorse

규칙을 찾아서 풀었습니다. 일단 간단하게 설명을 해보자면,, dot과 dash를 이용해 최대한 짧은 길의 모스부호를 만드는 문제라고 이해를 했습니다. dot (1) , dash(3) , dot과 dot 사이 혹은 dot과 dash, dash 와 dash 사이의 길이는 1입니다. 따라서 빈도수가 높은 문자에는 낮은 길이의 모스부호를 배정하는 것이 우선입니다.

[Remores 문제 자세한 풀이](https://zzoming-25.tistory.com/45)

1) 문자열을 입력받아 만일 영어일 경우, 대문자로 변환하여 공백을 제거하는 조건을 걸었습니다.

2) 빈도가 높은 문자열에 적은 길이의 모스부호를 배정해야 하기에 Counter함수를 이용해 각 문자별 빈도를 계산하고, dict 형태를 list로 변환하였습니다.

3) 일단은 모스부호로 만들 수 있는 길이와 그 수를 계산해봤을때, 길이가 1인 모스부호가 1개, 길이가 3인 모스부호가 2개, 길이가 5인 모스부호가 3개, 길이가 7인 모스부호가 5개, 길이가 9인 모스부호가 8개, 길이가 11인 모스부호가 13 으로 길이는 +2 씩 증가하고 해당 길이를 가진 모스부호 개수는 피보나치 수열처럼 증가했습니다. 해당 아이디어를 활용하여 풀이했습니다.

4) 그리고 zip 함수를 이용해 문자 빈도수와 모스부호 길이 리스트를 곱하고, 문자 간 공백의 길이(3) 까지 더해주어 최종 답을 구했습니다.
