# ✍🏻 3주차 회고 

## **[이분 탐색 알고리즘](https://zzoming-25.tistory.com/50#%EC%9D%B4%EB%B6%84%20%ED%83%90%EC%83%89%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-1)**

- 순차탐색 : 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서 부터 데이터를 하나씩 확인하는 방법
- 이진탐색 : 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
    - 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색범위를 설정합니다.

단계마다 탐색범위를 2로 나누는 것과 동일하므로 연산횟수는 $log_2N$에 비례합니다.

다시 말해, 이진 탐색은 탐색범위를 절반씩 줄이며, 시간 복잡도는 $Olog_2N$ 에 비례합니다.
</br>

## [새롭게 알게된 지식]

### list operator `unpacking`

* 반복문을 적용하지 않고, `print(*list)` 을 실행하면 리스트의 원소가 한번에 출력된다. 
* python list에 Asterisk(*) 을 사용하면 리스트 압축 해제 O 

### input 과 sys.stdin.readline의 차이

* sys.stdin.readline은 한 줄 단위로 입력을 받기 때문에 개행문자가 항상 같이 입력된다. 
* 만약 1을 입력했다면 1/n 이 저장되는 것이다. →rstrip()을 붙여줘야 개행 제거 
* sys.stdin.readline()은 prompt message를 인수로 받지 않는다. 
* input()은 데이터가 하나씩 버퍼에 들어가는 반면, sys.stdin.readline()은 데이터가 한번에 버퍼에 들어가므로 input() 보다 빠르다. 

### bisect 라이브러리

- bisect_left( a , x ) :정렬된 순서를 유지하면서 배열 a 에 x 를 삽입할 가장 왼쪽 인덱스를 반환
- bisect_right( a , x ) :정렬된 순서를 유지하면서 배열 a 에 x 를 삽입할 가장 오른쪽 인덱스를 반환
- 값이 특정범위에 속하는 데이터 개수를 구할  때 유용하다.
</br>

## [문제풀이]

1. 1920 - 수 찾기

처음에는 만일 주어진 리스트 안에 찾고자 하는 수가 있다면 1을 출력하고 아닐 경우 0을 출력하라는 코드를 작성했습니다. 해당 코드를 작성했을 때 **시간초과** 가 발생했고, 시간복잡도를 줄이기 위해 이분탐색을 활용하여 풀이했습니다.

    a. 이분탐색으로 수를 찾기 위해 N개의 숫자가 주어진 리스트를 오름차순으로 정렬 
    b. 시작점이 끝점보다 커지지 않을 때 까지 반복 (중간점 = (시작점 + 끝점 ) // 2)
    c. 찾고자 하는 수가 중간점 보다 클 경우 시작점을 중간점 +1 로 설정, 작을 경우 끝점을 중간점 -1로 설정

2. 2805 - 나무자르기

이 문제 역시 이분탐색을 활용하여 최대 절단점을 찾았습니다.

    a.  나무의 길이가 절단점 보다 클 경우 가져갈 수 있는 나무의 길이 (나무의 총 길이 - 절단점) 을 total에 누적
    b.  이 때, total은 적어도 주어진 M보다 커야 한다. 
    c.  만일 M보다 작을 경우 절단점을 줄여 더 많은 나무의 길이를 얻어야 하고, 클 경우 절단점을 늘려 최대 절단점을 찾는다.
    d.  M보다 작을 경우 끝점을 mid -1 로 설정, M보다 클 경우 시작점을 mid +1 로 설정하여 절단점 계산 
    e.  조건을 충족하는 경우 result에 절단점을 저장하여 계속해서 업데이트

3. 2110 - 공유기 설치 [민규님의 힌트]
 
    a.  공유기의 위치를 오름차순으로 정렬<br>
    b.  만일 설정된 거리보다 인접한 두 공유기 사이의 거리가 길다면 공유기 설치<br>
    c.  공유기를 설치한 위치를 현재 위치로 업데이트 후 주어진 개수의 모든 공유기 설치<br>
    d.  만일 범위 내 공유기 설치를 완료했다면 True 반환 아니라면 False 반환 <br>
    e.   인접한 최대 거리를 이분탐색으로 찾기 (만일, 공유기 설치를 완료했다면 최대의 거리를 업데이트하기 위해 시작점을 mid + 1로 설정하며 범위를 벗어난 경우에는 거리를 줄이기 위해 끝점은 mid -1로 설정)


5. 24511 - queustack

* 처음에는 자료구조의 개수만큼 큐와 스택을 생성하여, 큐일 경우 popleft을 진행해서 다음 자료구조에 넘겨주고, 스택일 경우 pop를 진행하여 다음 자료구조에 넘겨주는 방향으로 코드를 작성했습니다.
* 해당 방법으로 작성했을 때 시간초과가 발생했고, 다시 한번 적어보며 생각해보니 스택은 원소를 추가했다 빼는건 아무것도 하지 않는 것과 동일한 결과를 가져옵니다. 또한 큐는 먼저 삽입된 원소가 먼저 출력되는 특징이 있습니다.
* 따라서 자료구조가 큐일 경우에만 원소를 추가한 다음, 자료구조에 삽입할 원소를 appendleft 진행 후 pop을 실행하게되면 먼저 입력받은 순서대로 원소가 출력되게 됩니다.

5. 1874 - 스택수열

해당 문제는 수열을 pop 과 push를 반복하면서 주어진 리스트의 순서 생성하는 문제였습니다.

    a. 첫번째 원소 까지 append 진행
    b. 만일 stack의 마지막 원소가 주어진 리스트의 원소와 동일하다면 pop 진행 
    c. 만일 위의 방법으로 수열을 만들 수 없는 경우 False 반환 
    d. append가 진행될 때마다 + 추가 pop이 진행 될 때마다 - 추가 5. unpacking 을 활용하여 리스트를 한번에 출력하되, 엔터를 기준으로 출력한다.

6. 1966 - 프린터큐

머릿속으로 잘 그려지지 않아 직접 찍어가면서 풀이했습니다.

    a. 문서의 중요도와 인덱스를 함께 큐에 추가하여 만일 중요도가 가장 높은 문서가 출력 되었을 경우 꺼내고, 아닐 경우 젤 뒤에 추가한다. 
    b. 중요도가 같을 경우도 있으니, 몇번째로 인쇄되었는지 궁금한 문서를 구별하기 위해 인덱스도 같이 큐에 추가 
    c. 큐에서 중요도가 가장 큰 문서가 출력 될 때마다 count 누적 합 계산 
    d. 순서를 알고자 하는 문서가 출력되었을 경우 count 출력
