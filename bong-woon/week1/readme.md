
## < 1주차 회고 (그리드 알고리즘) >
---
### [1주차] 해결한 과제
##### 문제 30018 : 타슈
- https://www.acmicpc.net/problem/30018

**<접근 방법>**  

ex) 예시 출력  
$a_n$ = 3 1 4 2  
$b_n$ = 2 2 3 3  
result : 2  
  
- 예시 출력에서는 각 대여소 별 차이($b_n - a_n$)는 -1, +1, -1, +1입니다. -1은 한 대가 부족하다는 의미이고, +1은 원래보다 한 대가 많다는 의미가 됩니다. 이런 경우 원래보다 한 대 많은 곳의 자전거를 한 대 부족한 대여소로 옮겨주면 됩니다. 다시 말해, 영우는 원래 배치보다 많이 배치된 자전거를 원래 배치보다 부족한 대여소로 옮겨주면 됩니다. 그러면 $b_n - a_n$ 의 값이 +가 되는 경우를 모두 더하면 영우가 옮겨야 할 자전거 개수가 되고, 영우는 한 개씩 옮길 수 있으므로 자전거 개수가 곧 최소 옮겨야 할 횟수가 됩니다.  

---

##### 문제 16435 : 스네이크버드
- https://www.acmicpc.net/problem/16435

**<접근 방법>**  

ex) 9 1  
    9 5 8 1 3 2 7 6 4  
  
과일의 개수가 9개, 처음 스네이크 버드의 길이가 1인 상태에서 과일의 높이가 예제처럼 주어졌을 때, 그냥 for 문을 돈다면 앞에서부터 9, 5, 8 높이의 과일은 먹지 못하게 됩니다. 그래서 스네이크버드가 먹을 수 있는 사과는 모두 먹을 수 있도록 코드를 작성했습니다.

---

##### 문제 11399 : ATM
- https://www.acmicpc.net/problem/11399

**<접근 방법>**  

- 처음 온 사람의 인출하는데 걸리는 시간은 n번만큼 더 해집니다. 즉, 앞쪽에 선 사람의 소요 시간이 뒷쪽에 있는 사람의 소요 시간 보다 자주 더해지므로 시간이 최소가 되게 하려면 자주 더해지는 시간을 작게 해야 최소가 된다고 생각했습니다.  

---

##### 문제 1439 : 뒤집기
- https://www.acmicpc.net/problem/1439

**<접근 방법>**  
  
- 먼저 0과 1을 구분지어서 0과 1의 그룹의 개수를 각각 세었을 때, 적은 숫자가 곧 최소 행동 횟수가 된다는 생각을 했습니다. 규칙을 찾으려고 했고, 찾은 규칙으로 코드를 작성했습니다.  

---

##### 문제 10610 : 30
- https://www.acmicpc.net/problem/10610

**<접근 방법>**  
  
- 처음에는 양수 N을 이루는 모든 자릿수를 줄 세우는 모든 경우의 수를 하나씩 확인해서 30의 배수를 확인하는 방법으로 접근을 했었습니다. 하지만 VSCode에서는 정답이 출력이 되긴 했지만 백준에서는 '시간 초과' 문제가 발생했습니다.  
- 다시 고민하다가 배수 판정법이라는 것을 알게 되었고, 30의 배수가 되는 조건은 '3의 배수이면서 일의 자리가 0이어야 한다' 였습니다. 이 조건을 활용해서 30의 배수가 아닌 것을 먼저 확인하고 나머지 경우 중에서 최댓값을 구하는 식으로 접근했습니다.  

---
---
### [1주차] 해결하지 못한 과제

##### 문제 18008 : Remorse
- https://www.acmicpc.net/problem/18008

**<접근 방법>**  
  
- 처음에는 공백과 특수문자를 빼고 대문자로 통일하는 것 자체가 모스 부호의 길이를 최소화 하는 과정이라고 생각했습니다. 그래서 모스 부호표를 가지고 모스 부호의 길이를 출력했는데 다른 과정이 필요한 것 같습니다. 

---
---
### [1주차] 처음 써본 함수 및 라이브러리
- `from itertools import permutations`
    - 순열을 구현하는 라이브러리
    - 모든 경우의 수를 튜플 형태로 반환
    - ex)
    ```python
    from itertools import permutations

    for num in permutations('123'):
        print(num)
    
    # >> (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)
    # >> 경우의 수는 3! = 3 x 2 x 1 = 6
    ```
- 30 문제를 풀 때 순열로 접근해서 `permutation`을 써봤습니다.
- 백준에서 '시간 초과' 문제가 발생한 이유는 기본적으로 `permutation`의 시간 복잡도는 $O(N!)$라고 합니다. 문제에서 양수 N은 최대 $10^5$개의 숫자로 구성된다고 했으므로, `permutation`을 사용하면 30 문제의 시간 복잡도는 $O(10^5 !)$이 되므로 시간 초과 문제가 발생했던 것 같습니다.
=======


