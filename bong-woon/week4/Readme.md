
## < 4주차 회고 (정렬) >
---
### [4주차] 해결한 과제
##### 문제 3273 : 두 수의 합
- https://www.acmicpc.net/problem/3273

**<접근 방법>**  
  
- 배열을 우선 오름차순 정렬 하고 양쪽 끝의 두 원소를 가지고 시작합니다. 선택한 두 원소의 합이 만들려고 하는 x랑 같으면 count를 증가시켜줍니다.
    - 두 수의 합이 x보다 작은 경우에는 start를 1 증가시켜서 그 다음 원소를 가지고 다시 합을 구합니다.
    - 두 수의 합이 x보다 큰 경우에는 end를 1 감소시켜서 바로 앞의 원소를 가지고 다시 합을 구합니다.
    - start와 end가 같아지면 반복분을 종료하고 최종 count를 출력합니다.

---

##### 문제 2075 : N번째 큰 수
- https://www.acmicpc.net/problem/2075

**<접근 방법>**  

- 민규님의 도움을 받아 `heapq`를 활용해야 한다는 생각을 가지고 접근을 했습니다.
    - 처음에는 빈 리스트 h_tree를 만든 뒤, `heapq.heappush()`를 이용해서 입력하는 값을 하나씩 모두 넣은 뒤, 뒤에서 n번째 원소를 인덱싱 하려고 했습니다. 하지만 `h_tree[-n]`으로 인덱싱한 결과가 정확하게 n번째로 큰 원소가 되지는 않았습니다.
    - 그래서 heapq에 대해서 조금 더 찾아보다가 기본적으로 파이썬 heapq는 최소 힙만 제공하고 최대 힙을 만들기 위해선 약간의 테크닉이 필요한데, 입력되는 모든 값에 -를 붙여서 heapq에 넣으면 절댓값이 큰 원소가 가장 작은 원소로 들어가게 됩니다. VS Code에서는 예제 출력이 잘 나왔으나 백준에서는 메모리 초과 문제가 발생했습니다.
    - 메모리를 줄일 수 있는 방법을 알아봤는데, 기본적으로 리스트에 원소가 많으면 많을수록 메모리가 증가한다고 합니다. 그래서 이 문제의 경우 최대 1500 x 1500개의 원소가 들어가야 하기 때문에 메모리 초과 문제가 발생한다고 판단했습니다. 그래서, 한 줄씩 확인하는 방법을 생각했고, n개의 데이터를 리스트에 담고, 그 다음 원소부터는 현재 힙에 있는 최솟값과 비교해서 리스트에 값을 넣고 뺄지를 판단하는 방법으로 접근했습니다. n = 5인 예제의 경우를 가져오면
        - \[12 7 9 15 5\]를 heapq 구조에 넣으면 \[5 7 9 12 15\]로 정렬이 됩니다. 그리고 그 다음 원소 13과 리스트의 최솟값 5를 비교합니다. 리스트의 최솟값을 추출하기 위해서는 `heapq.heappop()`을 활용합니다. 그리고 13 > 5이므로 5는 pop을 해서 리스트에서 제거를 하고, 13을 `heapq.heappush()`로 추가합니다. 그리고 \[7 9 12 13 15\]가 자동으로 정렬됩니다. 이런 식으로 마지막 원소까지 반복을 하면 최종적으로 리스트에는 \[5번째로 큰 원소, 4번째로 큰 원소, 3번째로 큰 원소, 2번째로 큰 원소, 첫번째로 큰 원소\]가 됩니다. 그리고 이 리스트에서 `heapq.heappop()`을 하면 원하는 5번째(n번째)로 큰 원소를 출력할 수 있습니다.

---

##### 문제 1931 : 회의실 배정
- https://www.acmicpc.net/problem/1931

**<접근 방법>**  

- 어떤 값을 기준으로 정렬을 해야 할지에 대해서 생각해 내는 것이 생각보다 어려웠습니다. 결론적으로는 **회의가 끝나는 시간을 먼저 오름차순 정렬**을 하고, 회의가 끝나는 시간이 똑같은 경우에는 **회의를 시작하는 시간이 작은 쪽이 앞으로 오게 오름차순 정렬**을 합니다.
- idx = 0을 가지고 정렬 후 가장 앞에 위치하는 회의 시간대를 가져오고, 지금 회의 끝나는 시간과 다음 회의의 시작 시간을 비교해서 다음 회의 시작 시간이 지금 회의 끝나는 시간보다 크거나 같으면 회의실을 쓸 수 있으므로 count를 증가시켜줍니다.

---

##### 문제 18110 : solved.ac
- https://www.acmicpc.net/problem/18110

**<접근 방법>**  

- 구현 자체는 어렵지 않았으나 크게 두 가지 문제가 있었습니다. 
    - 첫번째는 시간 초과 문제였습니다. VS Code에서는 예제 출력대로 잘 출력을 했으나 백준에서는 시간 초과 문제가 발생했습니다. 의견의 개수가 최대 $3 \times 10^5$개이므로, 이러한 케이스에서 시간 초과 문제가 발생하는 것 같았습니다. 근본적인 원인을 해결하지 못하고, Pypy가 python보다 속도가 조금 더 빠르다는 얘기를 봐서 Pypy로 제출을 하니 똑같은 코드였지만 시간 초과 문제가 발생하지 않았습니다. 
    - 두번째는 파이썬의 round 함수였습니다. 파이썬의 round 함수를 그냥 사용하면 VS Code에서는 예제 출력대로 잘 출력이 됐으나 백준에서는 오답으로 판정을 했습니다. 그 이유는 파이썬의 round 함수는 우리가 일반적으로 잘 알고 있는 반올림 규칙과 다른 규칙으로 적용됐기 때문입니다. 그래서 우리가 일반적으로 잘 알고 있는 반올림을 수행할 함수를 따로 정의한 뒤, 그 함수를 사용해서 반올림을 수행했습니다.

---

##### 문제 14753 : Multimax
- https://www.acmicpc.net/problem/14753

**<접근 방법>**  

- 2장을 뽑아서 최대가 되는 경우와 3장을 뽑아서 최대가 되는 경우를 모두 고려해야 합니다. 경우의 수는 다음과 같습니다.
    - 2장을 뽑아서 최대가 되는 경우
        - 가장 작은 음수 2개를 곱하는 경우
        - 가장 큰 양수 2개를 곱하는 경우
    - 3장을 뽑아서 최대가 되는 경우
        - 가장 큰 양수 3개를 곱하는 경우
        - 가장 작은 음수 2개와 가장 큰 양수 1개를 곱하는 경우

- 그러기 위해서 먼저 입력한 값들을 오름차순으로 정렬하고 각각의 경우를 모두 계산한 후 그 중에서 최댓값을 출력하도록 작성했습니다.

---
---
### [4주차] 해결하지 못한 과제

##### 문제 2470 : 두 용액
- https://www.acmicpc.net/problem/2470

**<접근 방법>**  
- 지난주에 풀었던 공유기 문제와 유사한 아이디어로 풀 수 있을거라고 생각했는데 그것보다 더 구현이 어려웠던 것 같습니다.

---
---
### [4주차] 처음 써본 함수 및 라이브러리

#### 파이썬 round 함수의 원리
- 파이썬 round 함수는 우리가 알고 있는 일반적인 반올림 규칙을 따라가지 않습니다.
    ```python
    print(round(0.5)) # 0
    print(round(1.5)) # 2
    print(round(2.5)) # 2
    print(round(3.5)) # 4
    print(round(4.5)) # 4
    print(round(5.5)) # 6
    print(round(6.5)) # 6
    ```
- 파이썬은 정수 부분이 홀수인 경우는 일반적인 반올림을 수행하지만 정수 부분이 0을 포함한 짝수인 경우에는 소수점 이하를 버리고 그 정수를 출력합니다. 이처럼 반올림을 하는 방법에는 우리가 알고 있는 규칙 말고도 다른 규칙들도 있습니다.
    - **Round half up** : 사사오입이라고도 하는 일반적으로 알고 있는 반올림 규칙입니다.
    - **Round half to even** : 오사오입이라고 하는 방법입니다. 5를 초과하면 올림, 5 미만인 경우는 버림을 하지만 5인 경우에는 그 앞자리 숫자가 짝수일 경우에는 버림을 수행하고, 홀수인 경우에는 올림을 수행합니다. <u>파이썬 round 함수의 원리는 Round half to even입니다.</u>
    - **Round half down** : 오사육입이라고도 하는데 사사오입의 반대되는 개념으로 사사오입은 5 ~ 9일 때는 올림을 하지만 오사육입은 6 ~ 9일 때만 올림을 하고 0 ~ 5는 내림을 합니다.

