문제 링크 : boj.kr/6059

문제 요약 : N 마리의 소가 N 개의 목장에 한 마리씩 있다. 어떤 목장들은 L의 길이로 연결되어있다.
여행을 가고싶어하는 소의 번호와 목적지를 입력받아서 각 소의 여행가는데 드는 길이를 출력하면 된다.
A 목장에서 B 목장으로 가는 방법은 하나만이 존재한다. (따라서 목장은 트리형태를 이룬다.)

잘못된 접근 방법 :
우선 처음에는 문제 요약의 마지막부분(A목장과 B목장 사이의 경로는 하나이다)을 확인하지 못하고 다익스트라 알고리즘을 구현하는 방식으로 접근하였다.
다익스트라 알고리즘이란, 각 정점으로부터 특정 정점까지의 최단 거리를 구하는 알고리즘인데, 
작동방식을 간단하게 설명하자면 특정점 A와 가장 가까운 B를 구해 A와 B사이의 최단거리를 고정하고, (A에서 B 다음으로 가까운 C)와 (B에서 가장가까운 D의거리 + A에서 B까지의 거리)를 비교하여 그 다음으로 고정될 정점을 선택하는 방식으로 모든 정점까지의 최단거리를 구할 수 있다.
각 노드간의 거리를 계속 비교해야 하므로 내가 구현한 방식의 시간복잡도가 O(N^2)이상이 될 것으로 추정되고, 이 문제의 시간 제한을 통과하지 못하였다.
이 접근방법을 문제파일 맨 아래쪽에 주석으로 작성하였다.

접근 방법 :
우선 2차원 배열(이하 length)을 사용하여 연결된 목장사이의 거리를 표현하였다. (1번 목장과 2번 목장사이의 길이가 10이라면 length[1][2] = 10, length[2][1] = 10 이런식으로)
A목장과 B목장이 연결되어있음을 표현하기위해 원소가 집합(set)인 배열(이하 connected)을 사용하였다. (1번 목장이 2번 목장, 7번목장과 연결되어있는 경우 connected[1] = {2, 7}, connected[2] = {1}, connected[7] = {1} 이런식으로, set을 사용한 이유 : 중복된 값이 들어올 수 없어 list보다 시간을 절약할 수 있었다.)
여행을 하고싶어하는 소의 목장과 연결된 목장들을 connected배열을 사용하여 찾는다. 개인적으로 DFS보다 구현이 쉽다고 생각하는 BFS를 사용하여 구현하였다.
연결된 목장들과 해당하는 길이를 차례로 Queue에 넣고, 하나씩 pop하며 길이를 더하다가, 목적지 목장을 발견한 경우 목적지까지의 길이를 출력한다.