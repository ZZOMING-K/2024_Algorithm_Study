## WEEK5 다이나믹 프로그래밍 

### 11053.가장 긴 증가하는 부분 수열 

처음에는 단순하게 이전 수와 비교해서 만일 증가할 경우 수를 세고 아닐 경우 제외하는 방식으로 풀이했습니다. 

위와 같은 방식으로 풀이할 경우 런타임에러가 발생하여 다른 접근 방식을 사용해야 했습니다. 

접근방식은 다음과 같습니다. 

DP[i] :  **i번째에서 얻을 수 있는 가장 긴 증가하는 수열의 길이** 

1. 현재 위치 원소보다 이전 위치에 있는 원소들이 작은지 확인 
2.만일 작다면 현재 위치의 이전 숫자 중 **DP 최대값 +1** 과 **현재 값** 중 최대값으로 DP값 업데이트 

### 2579. 계단오르기 
DP[i] :  **i번째 계단을 밟았을 때 얻을 수 있는 최대 점수** 

DP[1] = a[1] → 첫번째 계단 

DP[2] = a[1] + a[2] → 두번째 계단에서 얻을 수 있는 최대 점수 

DP[3] = max(a[1] + a[3] , a[2]+a[3] ) 

- 첫번째 계단, 세번째 계단을 밟는 경우
- 두번째 계단, 세번째 계단을 밟는 경우

DP[4] =  max( **a[1]** + a[3] + a[4] , **a[1] + a[2]** + a[4] )

- 4번째 계단을 무조건 밟아야 함
- 3번째 계단을 밟는 경우와 3번째 계단을 밟지 않는 경우로 나눌 수 있음. 
    - 3번째 계단을 밟는 경우에는 두번째 계단을 밟으면 안됨
    - 3번째 계단을 밟지 않는 경우에는 두번째 계단과 첫번째 계단을 밟을 수 있음

DP[5] = max(  **DP[2]** + a[4] + a[5] ,  **DP[3]** + a[5] )

- 5번째 계단을 무조건 밟아야 함
- 4번째 계단을 밟는 경우와 밟지 않는 경우
    - 4번째 계단을 밟는 경우 → 3번째 계단을 밟지 말아야 함
        - 이때 DP[2] → 2번째 계단을 밟을 때 얻을 수 있는 최대 점수가 구해져 있으므로 계산된 DP[2] 를 사용하면 됨.
    - 4번째 계단을 밟지 않는 경우 3번째 계단을 밟을 수 있음
        - 3번째 계단에서 얻을 수 있는 최대 점수가 이미 구해져있으니 이를 이용 


### 1912. 연속합 

연속된 수를 선택하여 구할 수 있는 합 중 가장 큰 합을 구하는 문제입니다. 

접근방식은 다음과 같습니다. 

1. 연속된 수들의 누적합을 구한다. 
2. 만일 누적합이 음수가 될 경우 0으로 갱신한 뒤, 다음 숫자부터 다시 누적합을 계산한다. 
3. 이 과정을 반복하면서, 만일 `누적합`이 `현재까지 계산된 최대합`보다 클 경우 최대합으로 계속해서 업데이트 해준다. 
4. 음수를 고려하여 최대합의 초기값은 -10001로 설정한다. 
    - 숫자의 최저값은 -10000이며, 최대합이 음수가 될 수도 있으므로 초기값은 0이 아닌 가능한 가장 작은 값으로 설정한다.  



### 9461.파도반수열 

P(1) = 1 
P(2) = 1 
P(3) = 1 
P(4) = 2  = P(1) + P(2) 
P(5) = 2  = P(2) + P(3) 
P(6) = 3 = P(3) + P(4) 
P(7) = 4 = P(4) + P(5) 
P(8) = 5 = P(5) + P(6) 
P(9) = 7 = P(6) + P(7) 
P(10) = 9 = P(7) + P(8) 
P(11) = 12= P(8) + P(9) 
P(12) = 16 = P(9) + P(10)
... 

적다보니 N번째 나선에 있는 정삼각형 변의 길이는 2,3번째 전의 정삼각형 변의 길이의 합이라는 규칙을 발견했습니다. 

→ `P(N) = P(N-3) + P(N-2)`  


N의 최대 수는 100이므로 100번째 정삼각형 변의 길이를 담은 배열을 생성한 뒤, 
원하는 위치의 변의 길이를 출력하는 방식으로 코드를 작성했습니다. 
