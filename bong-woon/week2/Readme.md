
## < 2주차 회고 (BFS/DFS) >
---
### [2주차] 해결한 과제
##### 문제 10026 : 적록색약
- https://www.acmicpc.net/problem/10026

**<접근 방법>**  
  
- DFS 알고리즘을 사용했는데 일반적인 dfs 함수와 적록색약인 경우의 dfs_rg 함수 두 개를 정의해서 풀었습니다. 두 개의 코드는 거의 유사하나 dfs_rg에는 R, G를 구분하지 않는 조건을 추가했습니다.
```python
if ((map[nx][ny] == 'R' and current_color == 'G') or (map[nx][ny] == 'G' and current_color == 'R')) and check[nx][ny] == False:
    dfs_rg(nx, ny)
```
- 백준에 제출할 때는 Recursion Error가 발생했으나 `sys.setrecursionlimit(10**6)`를 통해 최대 재귀 한도를 설정해주니 결과가 나왔습니다.

---

##### 문제 6186 : Best Grass
- https://www.acmicpc.net/problem/6186

**<접근 방법>**  

- DFS 알고리즘을 이용해서 풀었습니다. '#'을 만나는 경우에만 상하좌우로 이동한 후 탐색을 하고, 이동한 위치에서 재귀적으로 DFS 탐색을 수행합니다. 그래서 상하좌우로 탐색이 계속 이어지다가 True를 반환하는 경우는 이어진 '#'을 더이상 못 찾은 경우입니다. DFS가 True를 반환하는 횟수가 '#'뭉치의 개수가 됩니다.

---

##### 문제 17265 : 나의 인생에는 수학과 함께
- https://www.acmicpc.net/problem/17265

**<접근 방법>**  

- (1, 1)에서 (5, 5)까지 가는 모든 경우의 수를 따라가면서 그 값을 문자열로 하나씩 이어붙이면서 경우의 수마다 하나의 수식을 만든 뒤, 모든 수식들을 계산하고 그 중에서 최댓값과 최솟값을 구하자고 생각했습니다.
- 처음에는 수식을 계산하는 앞에서부터 계산한 값을 어떻게 계속 갱신하면서 연산을 이어나갈지에 대한 구상이 잘 되지 않았고, eval()이라는 함수도 알게 되었지만 eval()은 기존의 연산법칙대로 계산을 해서 정답이 나오지 않았습니다.
- 그래서 수식을 아래 예시처럼 잘라서 생각한 다음, 수식을 담고 있는 문자열의 인덱스가 짝수(0은 제외)인 경우마다 이어붙인 수식을 eval()을 통해 계산을 합니다. 계산한 값을 다시 문자열로 만들어서 다음 짝수번 인덱스까지의 원소를 이어붙인 다음 다시 eval()을 통해서 계산해서 앞에서부터 차례대로 연산을 진행하도록 했습니다.

<br>

> 예시. '5 * 4 - 1 * 5 + 2'을 계산하는 과정
>
> 원소별 인덱스 = ('5', 0) ('*', 1) ('4', 2) ('-', 3) ('1', 4) ('\*', 5) ('5', 6) ('+', 7) ('2', 8)
>1. '5 * 4 - 1 * 5 + 2' --->> '5 / * 4 / - 1 / * 5 / + 2 '
>2. '5' + '*' + '4' = '5\*4'  
>3. eval('5 * 4') = 20 -> str(20)
>4. '20 ' + '-' + '1' = '20-1'
>5. eval('20-1') = 19 -> str(19)
>6. '19' + '*' + '5' = '19\*5'
>7. eval('19\*5') = 95 -> str(95)
>8. '95' + '+' + '2' = '95+2'
>9. eval('95+2') = 97

---

##### 문제 1260 : DFS와 BFS
- https://www.acmicpc.net/problem/1260

**<접근 방법>**  
  
- 문제대로 DFS와 BFS를 활용하여 각각의 검색 순서를 출력하게 만들었습니다. 알고리즘 구현도 어려웠지만 입력되는 정보를 어떤 자료형태로 저장해서 활용할지, 그리고 어떻게 구현할 지가 어려웠습니다.

---
---
### [2주차] 해결하지 못한 과제

##### 문제 12761 : 돌다리
- https://www.acmicpc.net/problem/12761

**<접근 방법>**  
  
- 현재 위치 n에서 이동할 수 있는 8가지의 경우의 수를 가지고 m까지 도착하는데 이동횟수 중 최솟값을 찾아야 한다는 생각은 했습니다. 하지만 n에서 m까지 가는 모든 경우의 수에 대한 이동횟수와 그 중에서 최솟값을 어떻게 찾을 수 있을지에 대한 아이디어가 떠오르지 않았습니다.

---

##### 문제 6059 : Pasture Walking
- https://www.acmicpc.net/problem/6059

**<접근 방법>**  
  
- 길이 정보를 노드 간 연결된 길이 정보를 아래 예시처럼 딕셔너리를 원소로 하는 리스트로 구성했습니다.
>ex. 1 --- 2 ---- 3 (- : 길이 1)
>
>graph = [{ }, {2 : 3}, {1 : 3, 3 : 4}, {2 : 4}]
- DFS 알고리즘으로 탐색을 해서 막다른 곳에 도착했을 때, 그곳이 목적지인지 확인하고 지금까지 더해온 길이를 반환하면 되겠다고 생각했습니다. 하지만 막다른 곳에 도착했을 때, 그곳이 목적지가 아닌 경우에 지금까지 더해온 길이를 다시 어느 지점으로, 어떻게 초기화 할지에 대한 구현을 하지 못했습니다.

---
---
### [2주차] 처음 써본 함수 및 라이브러리
- `eval()`
    - 문자열로 구성된 수식을 알아서 계산해서 결과를 출력해주는 함수
    ```python
    equation = '3 + 5 * 2 - 7'
    ans = eval(equation)
    print(ans)
    # >> 6
    ```
- '나의 인생에는 수학과 함께' 문제를 쓸 때 사용해봤습니다. 기본적으로 우리가 알고 있는 사칙연산 순서대로 계산하기 때문에 수식을 통째로 넣었을 때는 원하던 결과가 나오지 않았지만 수식을 잘라서 eval()을 통해 계산하고, 그 결과를 다시 str 타입으로 바꿔서 다음 잘라놓은 수식을 이어붙인 뒤 계산하면서 원하는 결과를 도출할 수 있었습니다.


