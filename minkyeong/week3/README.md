# ✍🏻 3주차 회고 

## 문제풀이 
1. 1920 - 수 찾기 

처음에는 만일 주어진 리스트 안에 찾고자 하는 수가 있다면 1을 출력하고 아닐 경우 0을 출력하라는 코드를 작성했습니다. 해당 코드를 작성했을 때 **시간초과** 가 발생했고, 시간복잡도를 줄이기 위해 이분탐색을 활용하여 풀이했습니다. 

    1. 이분탐색으로 수를 찾기 위해 N개의 숫자가 주어진 리스트를 오름차순으로 정렬 
    2. 시작점이 끝점보다 커지지 않을 때 까지 반복 (중간점 = (시작점 + 끝점 ) // 2)
    3. 찾고자 하는 수가 중간점 보다 클 경우 시작점을 중간점 +1 로 설정, 작을 경우 끝점을 중간점 -1로 설정 

2. 2805 - 나무자르기

이 문제 역시 이분탐색을 활용하여 최대 절단점을 찾았습니다. 

    1. 나무의 길이가 절단점 보다 클 경우 가져갈 수 있는 나무의 길이 (나무의 총 길이 - 절단점) 을 total에 누적 
    2. 이 때, total은 적어도 주어진 M보다 커야 한다. 
    3. 만일 M보다 작을 경우 절단점을 줄여 더 많은 나무의 길이를 얻어야 하고, 클 경우 절단점을 늘려 최대 절단점을 찾는다.
    4. M보다 작을 경우 끝점을 mid -1 로 설정, M보다 클 경우 시작점을 mid +1 로 설정하여 절단점 계산 
    5. 조건을 충족하는 경우 result에 절단점을 저장하여 계속해서 업데이트  



3. 2110 - 공유기 설치 

    해당 문제는 민규님의 힌트를 얻어 풀이할 수 있었습니다. 
    
    1. 공유기의 위치를 오름차순으로 정렬  
    2. 만일 설정된 거리보다 인접한 두 공유기 사이의 거리가 길다면 공유기 설치 
    3. 공유기를 설치한 위치를 현재 위치로 업데이트 후 주어진 개수의 모든 공유기 설치 
    4. 만일 범위 내 공유기 설치를 완료했다면 True 반환 아니라면 False 반환 
    5. 인접한 최대 거리를 이분탐색으로 찾기 (만일, 공유기 설치를 완료했다면 최대의 거리를 업데이트하기 위해 시작점을 mid + 1로 설정하며 범위를 벗어난 경우에는 거리를 줄이기 위해 끝점은 mid -1로 설정)

4. 24511 - queustack

처음에는 자료구조의 개수만큼 큐와 스택을 생성하여, 큐일 경우 popleft을 진행해서 다음 자료구조에 넘겨주고, 스택일 경우 pop를 진행하여 다음 자료구조에 넘겨주는 방향으로 코드를 작성했습니다.  

해당 방법으로 작성했을 때 시간초과가 발생했고, 다시 한번 적어보며 생각해보니 스택은 원소를 추가했다 빼는건 아무것도 하지 않는 것과 동일한 결과를 가져옵니다. 

또한 큐는 먼저 삽입된 원소가 먼저 출력되는 특징이 있습니다. 

따라서 자료구조가 큐일 경우에만 원소를 추가한 다음, 자료구조에 삽입할 원소를 appendleft 진행 후 pop을 실행하게되면 먼저 입력받은 순서대로 원소가 출력되게 됩니다. 


5. 1874 - 스택수열

해당 문제는 수열을 pop 과 push를 반복하면서 주어진 리스트의 순서 생성하는 문제였습니다. 
    1. 첫번째 원소 까지 append 진행  
    2. 만일 stack의 마지막 원소가 주어진 리스트의 원소와 동일하다면 pop 진행 
    3. 만일 위의 방법으로 수열을 만들 수 없는 경우 False 반환 
    4. append가 진행될 때마다 + 추가 pop이 진행 될 때마다 - 추가 
    5. unpacking 을 활용하여 리스트를 한번에 출력하되, 엔터를 기준으로 출력한다. 

6. 1966 - 프린터큐

머릿속으로 잘 그려지지 않아 직접 찍어가면서 풀이했습니다. 

    1. 문서의 중요도와 인덱스를 함께 큐에 추가하여 만일 중요도가 가장 높은 문서가 출력 되었을 경우 꺼내고, 아닐 경우 젤 뒤에 추가한다. 
    2. 중요도가 같을 경우도 있으니, 몇번째로 인쇄되었는지 궁금한 문서를 구별하기 위해 인덱스도 같이 큐에 추가 
    3. 큐에서 중요도가 가장 큰 문서가 출력 될 때마다 count 누적 합 계산 
    4. 순서를 알고자 하는 문서가 출력되었을 경우 count 출력
