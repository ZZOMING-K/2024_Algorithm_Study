
## < 17주차 회고 (Summer/Winter Coding (~2018)) >
---
### [17주차] 해결한 과제
##### 점프와 순간이동
- https://school.programmers.co.kr/learn/courses/30/lessons/12980

**<접근 방법>**  
  
- 문제와 다르게 반대로 생각해서 임의의 지점 n에서 0까지 이동하는 경우로 생각했습니다. 이 때, 배터리 소모를 최소로 하기 위해서는 두 배로 이동하는 순간이동을 최대한 많이 해야합니다. 역으로 가는 것을 생각했기 때문에 순간이동은 현재 위치의 2배가 아니라 2로 나누어서 가는 것으로 생각할 수 있습니다. 이 때, 2로 나누어지지 않는 경우에는 배터리를 소모해서 한 칸 이동합니다.
- ex) n = 5000인 경우 0으로 이동하려면?
    - 5000 / 2 = 2500 (순간이동)
    - 2500 / 2 = 1250 (순간이동)
    - 1250 / 2 = 625 (순간이동)
    - 625 - 1 = 624 (배터리 소모 + 1) 
    - 624 / 2 = 312 (순간이동)
    - 312 / 2 = 156 (순간이동)
    - 156 / 2 = 78 (순간이동)
    - 78 / 2 = 39 (순간이동)
    - 39 - 1 = 38 (배터리 소모 + 1)
    - 38 / 2 = 19 (순간이동)
    - 19 - 1 = 18 (배터리 소모 + 1)
    - 18 / 2 = 9 (순간이동)
    - 9 - 1 = 8 (배터리 소모 + 1)
    - 8 / 2 = 4 (순간이동)
    - 4 / 2 = 2 (순간이동)
    - 2 / 2 = 1 (순간이동)
    - 1 - 1 = 0 (배터리 소모 + 1)
    -> 총 배터리 소모 : 5

---

##### 영어 끝말잇기
- https://school.programmers.co.kr/learn/courses/30/lessons/12981

**<접근 방법>**  
  
- for문을 통해 주어진 단어 리스트를 돌면서 끝말잇기가 성립하는지를 체크합니다.
    - for문을 도는 동안 number, repeat을 계속 계산해줍니다.
    - 끝말잇기가 성립하면 using_word 리스트에 사용한 단어를 추가합니다.
    - 성립하지 않으면 현재 계산된 number, repeat을 리스트 형태로 return 해줍니다.
- for문을 다 도는 동안 return 되지 않으면 끝말잇기는 끝까지 성립됐다는 의미이기 때문에 \[0, 0\]을 리턴해줍니다.


---

##### 방문 길이
- https://school.programmers.co.kr/learn/courses/30/lessons/49994

**<접근 방법>**  
  
- 현재 위치의 좌표와 상하좌우 이동 방향을 길이가 2인 리스트 형태로 표현한 뒤, 상하좌우 각각 이동하는 경우를 나누어서 처음 지나가본 길이라면 answer를 +1 해주면서 리턴해줍니다.
    - 상하좌우로 이동할 때는 정해진 맵을 벗어나지 않는지를 계속 체크해줍니다.
    - 이 때, 이동하는 경로는 total_path라는 리스트에 계속해서 추가해주면서 이 길이 지나갔던 길인지 처음 지나가는 길인지 확인해줍니다.
    - (0, 0)에서 (1, 0)으로 간 것과 (1, 0)에서 (0, 0)으로 간 것은 똑같은 길을 간 것이기 때문에 이 경우도 고려해줍니다.

---

##### 스킬 트리
- https://school.programmers.co.kr/learn/courses/30/lessons/49993

**<접근 방법>**  
  
- 유저들이 만든 스킬트리에서 선행 스킬트리와 비교했을 때 같은 스킬이 있다면 순서대로 sk_tree에 스킬을 하나씩 추가하면서 스킬트리를 만듭니다.
- 이렇게 만들어진 스킬트리가 선행 스킬트리와 같다면 가능한 스킬트리입니다.

---

##### 숫자 게임
- https://school.programmers.co.kr/learn/courses/30/lessons/12987

**<접근 방법>**  
  
- A와 B를 오름차순으로 정렬한 뒤, A와 B의 인덱스가 n보다 작은 동안 아래의 반복을 수행합니다.
    - A = \[1, 3, 5, 7\],  B = \[2, 2, 5, 8\]
    - 처음에는 A의 1과 B의 2를 비교합니다. 지금은 B의 숫자가 크기 때문에 B의 점수를 올려주고 그 다음 A팀의 사원과 B팀의 사원을 비교합니다.
    - 다음 A팀의 숫자는 3, B팀의 숫자는 2이므로 이번에는 B가 점수를 얻을 수 없습니다. 그러므로 A팀의 사원은 그대로 두고 그 다음 B팀의 사원을 불러옵니다. 오름차순으로 정렬했기 때문에 B팀의 다음 사원은 방금 숫자보다 최소한 작지 않습니다.
        - 따라서 다음에는 A는 3, B는 5와 비교합니다. 이번에는 B의 숫자가 크기 때문에 B팀은 점수를 얻을 수 있습니다.
    - 그 다음에는 A팀의 숫자 5와 B팀의 숫자 8을 비교합니다. 이번에도 B팀의 숫자가 크기 때문에 B팀의 점수를 올려주고, 그 다음 A와 B의 숫자를 불러옵니다.
        - 하지만 B팀은 이미 모든 선수가 나왔기 때문에 더 이상 진행할 수 없으므로 while문을 더 이상 수행할 수 없습니다.

---

##### 배달
- https://school.programmers.co.kr/learn/courses/30/lessons/12978

**<접근 방법>**  
  
- 다익스트라 알고리즘으로 푸는 문제였습니다. 기준이 되는 1번 마을에서 다른 마을까지의 최단 거리를 구한 뒤 그 거리가 K보다 작거나 같다면 answer를 +1 해주면서 최종적으로 총 배달할 수 있는 마을의 개수를 구합니다.

---

##### 기지국 설치
- https://school.programmers.co.kr/learn/courses/30/lessons/12979

**<접근 방법>**  
  
- for문을 이용해서 먼저 설치된 stations의 원소들을 기준으로 앞쪽에 커버하지 못하는 영역이 있다면 기지국을 설치합니다.
    - 기지국을 설치할 때는 커버하지 못하는 영역의 길이와 기지국이 커버하는 영역의 길이를 나누었을 때
        - 나누어 떨어지면 그 몫만큼 기지국을 설치하고
        - 나누어 떨어지지 않으면 그 몫에다가 +1 해준 것만큼 설치해야 합니다.
    - station의 앞쪽 영역은 체크했으므로 다음 체크할 영역은 station이 뒷쪽으로 커버할 수 있는 영역의 밖부터 다시 체크합니다.
- for문을 다 돌았다면 station의 앞쪽 범위는 모두 확인했고, 마지막 기지국 기준으로 뒷쪽에 커버하지 못하는 영역이 있는지 확인하고, 똑같은 방식으로 추가로 설치해야 하는 기지국의 개수를 더해줍니다.

---
---
### [17주차] 해결하지 못한 과제
##### 스티커 모으기(2)
- https://school.programmers.co.kr/learn/courses/30/lessons/12971

**<접근 방법>**  
  
- 



---
---
### [17주차] 처음 써본 함수 및 라이브러리

